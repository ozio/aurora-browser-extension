{"version":3,"sources":["webpack:///webpack/bootstrap df202241683c401b6f75","webpack:///./extension/src/base.ts","webpack:///./node_modules/reconnecting-websocket/dist/index.js","webpack:///./extension/src/chrome/index.ts","webpack:///./extension/src/chrome/adapter.ts","webpack:///./extension/src/chrome/manifest.json"],"names":[],"mappings":"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AAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,KAAK,OAAO,IAAI,WAAW,CAAC,CAAC;gBAAC,MAAM,CAAC;YAChE,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;YAEhC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;QACzC,CAAC;KAAA;CAOF;AAED,yDAAe,SAAS,EAAC;;;;;;;;AChGzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;AACA;AACA,0BAA0B,kBAAkB,EAAE;AAC9C,+BAA+B,mBAAmB,EAAE;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC,EAAE;AACtE,iCAAiC,mCAAmC,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK,KAAK;AACV;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B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","file":"./extension/build/chrome/extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap df202241683c401b6f75","import * as ReconnectingWebsocket from 'reconnecting-websocket';\n\nconst WEBSOCKET_PROTOCOL = 'ws';\nconst WEBSOCKET_PORT = 1337;\nconst WEBSOCKET_DOMAIN = 'localhost';\nconst WEBSOCKET_PATH = '';\nconst WEBSOCKET_URL = `${WEBSOCKET_PROTOCOL}://${WEBSOCKET_DOMAIN}:${WEBSOCKET_PORT}/${WEBSOCKET_PATH}`;\nconst API_VERSION = 1;\n\nabstract class Extension {\n  currentURL?: string = null;\n\n  isBrowserFocused?: boolean = null;\n\n  ws: ReconnectingWebsocket;\n\n  constructor() {\n    this.connect(WEBSOCKET_URL);\n    this.addListeners();\n    this.ws.addEventListener('open', async () => {\n      await this.updateFocus(true);\n      await this.updateCurrentURL(true);\n    });\n  }\n\n  static getURLData(url: string): URLData {\n    const urlObject = new URL(url);\n    const searchObject = {};\n\n    for (let item of urlObject.searchParams) {\n      searchObject[item[0]] = item[1];\n    }\n\n    return {\n      hash: urlObject.hash,\n      host: urlObject.host,\n      hostname: urlObject.hostname,\n      href: urlObject.href,\n      password: urlObject.password,\n      pathname: urlObject.pathname,\n      port: urlObject.port,\n      protocol: urlObject.protocol,\n      username: urlObject.username,\n      search: urlObject.search,\n      searchParams: searchObject,\n    };\n  }\n\n  connect(path: string) {\n    this.ws = new ReconnectingWebsocket(path);\n  }\n\n  sendMessage(type: MessageType, payload: MessagePayload) {\n    const message: Message = {\n      ...payload,\n      type,\n      version: API_VERSION,\n    };\n\n    try {\n      this.ws.send(JSON.stringify(message));\n    } catch(e) {}\n  }\n\n  async updateCurrentURL(forceUpdate?: boolean) {\n    const url = await this.getCurrentURL();\n    const urlHasChanged = url !== this.currentURL;\n\n    if (urlHasChanged || forceUpdate) {\n      if (url) this.currentURL = url;\n\n      if (!(this.isBrowserFocused === true || forceUpdate)) return;\n\n      this.sendMessage('url', {\n        ...Extension.getURLData(this.currentURL)\n      });\n\n    }\n  }\n\n  async updateFocus(forceUpdate?: boolean) {\n    const focused = await this.getFocused();\n\n    if (!(this.isBrowserFocused !== focused || forceUpdate)) return;\n    this.isBrowserFocused = focused;\n\n    this.sendMessage('focus', { focused });\n  }\n\n  abstract addListeners();\n\n  abstract getCurrentURL(): Promise<string>;\n\n  abstract getFocused(): Promise<boolean>;\n}\n\nexport default Extension;\n\n\n\n// WEBPACK FOOTER //\n// ./extension/src/base.ts","\"use strict\";\n;\n;\n;\nvar isWebSocket = function (constructor) {\n    return constructor && constructor.CLOSING === 2;\n};\nvar isGlobalWebSocket = function () {\n    return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);\n};\nvar getDefaultOptions = function () { return ({\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n}); };\nvar bypassProperty = function (src, dst, name) {\n    Object.defineProperty(dst, name, {\n        get: function () { return src[name]; },\n        set: function (value) { src[name] = value; },\n        enumerable: true,\n        configurable: true,\n    });\n};\nvar initReconnectionDelay = function (config) {\n    return (config.minReconnectionDelay + Math.random() * config.minReconnectionDelay);\n};\nvar updateReconnectionDelay = function (config, previousDelay) {\n    var newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n    return (newDelay > config.maxReconnectionDelay)\n        ? config.maxReconnectionDelay\n        : newDelay;\n};\nvar LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];\nvar reassignEventListeners = function (ws, oldWs, listeners) {\n    Object.keys(listeners).forEach(function (type) {\n        listeners[type].forEach(function (_a) {\n            var listener = _a[0], options = _a[1];\n            ws.addEventListener(type, listener, options);\n        });\n    });\n    if (oldWs) {\n        LEVEL_0_EVENTS.forEach(function (name) {\n            ws[name] = oldWs[name];\n        });\n    }\n};\nvar ReconnectingWebsocket = function (url, protocols, options) {\n    var _this = this;\n    if (options === void 0) { options = {}; }\n    var ws;\n    var connectingTimeout;\n    var reconnectDelay = 0;\n    var retriesCount = 0;\n    var shouldRetry = true;\n    var savedOnClose = null;\n    var listeners = {};\n    // require new to construct\n    if (!(this instanceof ReconnectingWebsocket)) {\n        throw new TypeError(\"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\");\n    }\n    // Set config. Not using `Object.assign` because of IE11\n    var config = getDefaultOptions();\n    Object.keys(config)\n        .filter(function (key) { return options.hasOwnProperty(key); })\n        .forEach(function (key) { return config[key] = options[key]; });\n    if (!isWebSocket(config.constructor)) {\n        throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');\n    }\n    var log = config.debug ? function () {\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i] = arguments[_i];\n        }\n        return console.log.apply(console, ['RWS:'].concat(params));\n    } : function () { };\n    /**\n     * Not using dispatchEvent, otherwise we must use a DOM Event object\n     * Deferred because we want to handle the close event before this\n     */\n    var emitError = function (code, msg) { return setTimeout(function () {\n        var err = new Error(msg);\n        err.code = code;\n        if (Array.isArray(listeners.error)) {\n            listeners.error.forEach(function (_a) {\n                var fn = _a[0];\n                return fn(err);\n            });\n        }\n        if (ws.onerror) {\n            ws.onerror(err);\n        }\n    }, 0); };\n    var handleClose = function () {\n        log('handleClose', { shouldRetry: shouldRetry });\n        retriesCount++;\n        log('retries count:', retriesCount);\n        if (retriesCount > config.maxRetries) {\n            emitError('EHOSTDOWN', 'Too many failed connection attempts');\n            return;\n        }\n        if (!reconnectDelay) {\n            reconnectDelay = initReconnectionDelay(config);\n        }\n        else {\n            reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n        }\n        log('handleClose - reconnectDelay:', reconnectDelay);\n        if (shouldRetry) {\n            setTimeout(connect, reconnectDelay);\n        }\n    };\n    var connect = function () {\n        if (!shouldRetry) {\n            return;\n        }\n        log('connect');\n        var oldWs = ws;\n        var wsUrl = (typeof url === 'function') ? url() : url;\n        ws = new config.constructor(wsUrl, protocols);\n        connectingTimeout = setTimeout(function () {\n            log('timeout');\n            ws.close();\n            emitError('ETIMEDOUT', 'Connection timeout');\n        }, config.connectionTimeout);\n        log('bypass properties');\n        for (var key in ws) {\n            // @todo move to constant\n            if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {\n                bypassProperty(ws, _this, key);\n            }\n        }\n        ws.addEventListener('open', function () {\n            clearTimeout(connectingTimeout);\n            log('open');\n            reconnectDelay = initReconnectionDelay(config);\n            log('reconnectDelay:', reconnectDelay);\n            retriesCount = 0;\n        });\n        ws.addEventListener('close', handleClose);\n        reassignEventListeners(ws, oldWs, listeners);\n        // because when closing with fastClose=true, it is saved and set to null to avoid double calls\n        ws.onclose = ws.onclose || savedOnClose;\n        savedOnClose = null;\n    };\n    log('init');\n    connect();\n    this.close = function (code, reason, _a) {\n        if (code === void 0) { code = 1000; }\n        if (reason === void 0) { reason = ''; }\n        var _b = _a === void 0 ? {} : _a, _c = _b.keepClosed, keepClosed = _c === void 0 ? false : _c, _d = _b.fastClose, fastClose = _d === void 0 ? true : _d, _e = _b.delay, delay = _e === void 0 ? 0 : _e;\n        log('close - params:', { reason: reason, keepClosed: keepClosed, fastClose: fastClose, delay: delay, retriesCount: retriesCount, maxRetries: config.maxRetries });\n        shouldRetry = !keepClosed && retriesCount <= config.maxRetries;\n        if (delay) {\n            reconnectDelay = delay;\n        }\n        ws.close(code, reason);\n        if (fastClose) {\n            var fakeCloseEvent_1 = {\n                code: code,\n                reason: reason,\n                wasClean: true,\n            };\n            // execute close listeners soon with a fake closeEvent\n            // and remove them from the WS instance so they\n            // don't get fired on the real close.\n            handleClose();\n            ws.removeEventListener('close', handleClose);\n            // run and remove level2\n            if (Array.isArray(listeners.close)) {\n                listeners.close.forEach(function (_a) {\n                    var listener = _a[0], options = _a[1];\n                    listener(fakeCloseEvent_1);\n                    ws.removeEventListener('close', listener, options);\n                });\n            }\n            // run and remove level0\n            if (ws.onclose) {\n                savedOnClose = ws.onclose;\n                ws.onclose(fakeCloseEvent_1);\n                ws.onclose = null;\n            }\n        }\n    };\n    this.send = function (data) {\n        ws.send(data);\n    };\n    this.addEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            if (!listeners[type].some(function (_a) {\n                var l = _a[0];\n                return l === listener;\n            })) {\n                listeners[type].push([listener, options]);\n            }\n        }\n        else {\n            listeners[type] = [[listener, options]];\n        }\n        ws.addEventListener(type, listener, options);\n    };\n    this.removeEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            listeners[type] = listeners[type].filter(function (_a) {\n                var l = _a[0];\n                return l !== listener;\n            });\n        }\n        ws.removeEventListener(type, listener, options);\n    };\n};\nmodule.exports = ReconnectingWebsocket;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/reconnecting-websocket/dist/index.js\n// module id = 1\n// module chunks = 0 1","import ChromeExtension from './adapter';\nimport './manifest.json';\n\nconst extension = new ChromeExtension();\n\n\n\n// WEBPACK FOOTER //\n// ./extension/src/chrome/index.ts","import Extension from '../base';\n\nclass ChromeExtension extends Extension {\n  addListeners() {\n    const updateFocusHandler = async () => {\n      await this.updateFocus();\n      if (this.isBrowserFocused) {\n        this.updateCurrentURL(true);\n      }\n    };\n\n    const updateUrlHandler = () => {\n      this.updateCurrentURL();\n    };\n    \n    chrome.windows.onFocusChanged.addListener(updateFocusHandler);\n\n    chrome.tabs.onCreated.addListener(updateUrlHandler);\n    chrome.tabs.onUpdated.addListener(updateUrlHandler);\n    chrome.tabs.onMoved.addListener(updateUrlHandler);\n    chrome.tabs.onActivated.addListener(updateUrlHandler);\n    chrome.tabs.onHighlighted.addListener(updateUrlHandler);\n    chrome.tabs.onDetached.addListener(updateUrlHandler);\n    chrome.tabs.onAttached.addListener(updateUrlHandler);\n    chrome.tabs.onRemoved.addListener(updateUrlHandler);\n    chrome.tabs.onReplaced.addListener(updateUrlHandler);\n  }\n\n  getCurrentURL(): Promise<string> {\n    return new Promise((resolve) => {\n      chrome.tabs.query(\n        {\n          active: true,\n          windowId: chrome.windows.WINDOW_ID_CURRENT\n        },\n        (tabs) => {\n          let url;\n\n          if (tabs[0] && tabs[0].url) {\n            url = tabs[0].url;\n          } else {\n            url = null;\n          }\n\n          resolve(url);\n        }\n      );\n    });\n  }\n\n  getFocused(): Promise<boolean> {\n    return new Promise((resolve) => {\n      chrome.windows.getCurrent(null, (window) => {\n        const focusedNow = window && window.focused;\n        resolve(focusedNow);\n      });\n    });\n  }\n}\n\nexport default ChromeExtension;\n\n\n\n// WEBPACK FOOTER //\n// ./extension/src/chrome/adapter.ts","module.exports = __webpack_public_path__ + \"./extension/build/chrome/manifest.json\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./extension/src/chrome/manifest.json\n// module id = 4\n// module chunks = 1"],"sourceRoot":""}